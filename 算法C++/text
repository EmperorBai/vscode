哈夫曼
6
45 13 12 16 9 5

a 0
b 101
c 100
d 111
e 1101
f 1100

Prime 
【问题描述】
Prim算法解决的是带权重的无向图上连接所有顶点的耗费最小的生成树。Q使用最小堆数据结构。

【输入形式】
在屏幕上输入顶点个数和连接顶点间的边的权矩阵。

【输出形式】
顺序输出按照贪心选择得到的各顶点序号，及该顶点的前驱顶点序号，及路径长度。
8
0  15 7  0 0  0  0  10
15 0  0  0 0  0  0  0
7  0  0  9 12 5  0  0 
0  0  9  0 0  0  0  0
0  0  12 0 0  6  0  0
0  0  5  0 6  0  14 8
0  0  0  0 0  14 0  3
10 0  0  0 0  8  3  0


3 1 7
6 3 5
5 6 6
8 6 8
7 8 3
4 3 9
2 1 15


Dijkstra

问题描述】
Dijkstra算法解决的是带权重的有向图上单源最短路径问题。所有边的权重都为非负值。设置顶点集合S并不断地作贪心选择来扩充这个集合。使用最小堆数据结构构造优先队列。第1个顶点为源。

【输入形式】
在屏幕上输入顶点个数和连接顶点间的边的权矩阵。

【输出形式】
从源到各个顶点的最短距离 及 路径。

【样例输入】

5
0 10 0 30 100
0 0 50 0 0
0 0 0 0 10
0 0 20 0 60
0 0 0 0 0

【样例输出】

10: 1->2
50: 1->4->3
30: 1->4
60: 1->4->3->5



深度优先搜索算法求解TSP

问题描述】
采用深度优先搜索算法求解TSP问题，并在搜索过程中，使用界限条件（当前结点已经走过的路径长度要小于已求得的最短路径）进行“剪枝”操作（不再对后续结点进行遍历），从而提高搜索效率。采用queue模块中的栈（LifoQueue）来实现深度优先搜索。

【输入形式】
在屏幕上输入顶点个数和连接顶点间的边的邻接矩阵，边上的权可能有小数点。

【输出形式】
在整个算法过程中的先后搜索路径（最多输出20次最先搜索的路径），最优值和其中一条最优路径。

【样例1输入】

4
0 30 6 4
30 0 5 10
6 5 0 20
4 10 20 0

【样例1输出】

1
1->2
1->2->3
1->2->3->4
1->2->4
1->3
1->3->2
1->3->2->4
1->3->4
1->4
1->4->2
1->4->2->3
1->4->3
25: 1->3->2->4
